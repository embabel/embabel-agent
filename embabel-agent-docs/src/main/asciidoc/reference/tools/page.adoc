[[reference.tools]]
=== Tools

Tools can be passed to LLMs to allow them to perform actions.
Tools can either be outside the JVM process, as with MCP, or inside the JVM process, as with domain objects exposing `@LlmTool` methods.

Embabel allows you to provide tools to LLMs in two ways:

* Via the `PromptRunner` by providing one or more in process **tool instances**.
A tool instance is an object with methods annotated with Embabel `@LlmTool` or Spring AI `@Tool`.
* At action or `PromptRunner` level, from a **tool group**.

`LlmReference` implementations also expose tools, but this is handled internally by the framework.

==== In Process Tools: Implementing Tool Instances

Implement one or more methods annotated with `@LlmTool` on a class.
You do not need to annotate the class itself.
Each annotated method represents a distinct tool that will be exposed to the LLM.

A simple example of a tool method:

[source,kotlin]
----
class MathTools {

    @LlmTool(description = "add two numbers")
    fun add(a: Double, b: Double) = a + b

    // Other tools
----

Classes implementing tools can be stateful.
They are often domain objects.
Tools on mapped entities are especially useful, as they can encapsulate state that is never exposed to the LLM.
See https://medium.com/@springrod/domain-tools-direct-access-zero-ceremony-9a3e8d4cf550[Domain Tools: Direct Access, Zero Ceremony] for a discussion of tool use patterns.

The `@Tool` annotation comes from https://docs.spring.io/spring-ai/reference/api/tools.html[Spring AI].

Tool methods can have any visibility, and can be static or instance scope.
They are allowed on inner classes.

[quote,Spring AI,Tool Calling]
____
You can define any number of arguments for the method (including no argument) with most types (primitives, POJOs, enums, lists, arrays, maps, and so on).
Similarly, the method can return most types, including void.
If the method returns a value, the return type must be a serializable type, as the result will be serialized and sent back to the model.

The following types are not currently supported as parameters or return types for methods used as tools:

- Optional
- Asynchronous types (e.g. CompletableFuture, Future)
- Reactive types (e.g. Flow, Mono, Flux)
- Functional types (e.g. Function, Supplier, Consumer).
____

You can obtain the current `AgentProcess` in a Tool method implementation via `AgentProcess.get()`.
This enables tools to bind to the `AgentProcess`, making objects available to other actions.
For example:

[source,java]
----

@LlmTool(description="My Tool") String bindCustomer(Long id) {
var customer = customerRepository.findById(id); var agentProcess = AgentProcess.get(); if (agentProcess != null) {
agentProcess.addObject(customer); return "Customer bound to blackboard"; } return "No agent process: Unable to bind customer"; }

----

[[reference.tools__tool-groups]]
==== Tool Groups

Embabel introduces the concept of a *tool group*.
This is a level of indirection between user intent and tool selection.
For example, we don't ask for Brave or Google web search: we ask for "web" tools, which may be resolved differently in different environments.

TIP: Tools use should be focused.
Thus tool groups are not specified at agent level, but on individual actions.

Tool groups are often backed by <<reference.integrations__mcp,MCP>>.

===== Configuring Tool Groups in configuration files

If you have configured MCP servers in your application configuration, you can selectively expose tools from those servers to agents by configuring tool groups.
The easiest way to do this is in your `application.yml` or `application.properties` file.
Select tools by name.

For example:

[source,yaml]
----
embabel:

    agent:
    platform:
      tools:
        includes:
          weather:
            description: Get weather for location
            provider: Docker
            tools:
              - weather
----

===== Configuring Tool Groups in Spring @Configuration

You can also use Spring's `@Configuration` and `@Bean` annotations to expose ToolGroups to the agent platform with greater control.
The framework provides a default `ToolGroupsConfiguration` that demonstrates how to inject MCP servers and selectively expose MCP tools:

[source,kotlin]
----

@Configuration class ToolGroupsConfiguration(
    private val mcpSyncClients: List<McpSyncClient>) {

    @Bean
    fun mathToolGroup() = MathTools()

    @Bean
    fun mcpWebToolsGroup(): ToolGroup { // <1>
        return McpToolGroup(
            description = CoreToolGroups.WEB_DESCRIPTION,
            name = "docker-web",
            provider = "Docker",
            permissions = setOf(ToolGroupPermission.INTERNET_ACCESS),
            clients = mcpSyncClients,
            filter = {
                // Only expose specific web tools, exclude rate-limited ones
                (it.toolDefinition.name().contains("brave") ||
                 it.toolDefinition.name().contains("fetch")) &&
                !it.toolDefinition.name().contains("brave_local_search")
            }
        )
    }
}
----

<1> This method creates a Spring bean of type `ToolGroup`.
This will automatically be picked up by the agent platform, allowing the tool group to be requested by name (role).

===== Key Configuration Patterns

**MCP Client Injection:**
The configuration class receives a `List<McpSyncClient>` via constructor injection.
Spring automatically provides all available MCP clients that have been configured in the application.

**Selective Tool Exposure:**
Each `McpToolGroup` uses a `filter` lambda to control which tools from the MCP servers are exposed to agents.
This allows fine-grained control over tool availability and prevents unwanted or problematic tools from being used.

**Tool Group Metadata:**
Tool groups include descriptive metadata like `name`, `provider`, and `description` to help agents understand their capabilities.
The `permissions` property declares what access the tool group requires (e.g., `INTERNET_ACCESS`).

===== Creating Custom Tool Group Configurations

Applications can implement their own `@Configuration` classes to expose custom tool groups, which can be backed by any service or resource, not just MCP.

[source,java]
----
@Configuration
public class MyToolGroupsConfiguration {

    @Bean
    public ToolGroup databaseToolsGroup(DataSource dataSource) {
        return new DatabaseToolGroup(dataSource);
    }

    @Bean
    public ToolGroup emailToolsGroup(EmailService emailService) {
        return new EmailToolGroup(emailService);
    }
}
----

This approach leverages Spring's dependency injection to provide tool groups with the services and resources they need, while maintaining clean separation of concerns between tool configuration and agent logic.

===== Using Tools in Action Methods

Tools are specified on the `PromptRunner` when making LLM calls.
This gives you fine-grained control over which tools are available for each specific prompt.

Here's an example from the `StarNewsFinder` agent that demonstrates web tool usage within an action:

[tabs]
====
Java::
+
[source,java]
----
@Action
public RelevantNewsStories findNewsStories(
        StarPerson person, Horoscope horoscope, OperationContext context) {
    var prompt = """
            %s is an astrology believer with the sign %s.
            Their horoscope for today is:
                <horoscope>%s</horoscope>
            Given this, use web tools and generate search queries
            to find %d relevant news stories summarize them in a few sentences.
            Include the URL for each story.
            Do not look for another horoscope reading or return results directly about astrology;
            find stories relevant to the reading above.
            """.formatted(
            person.name(), person.sign(), horoscope.summary(), storyCount);

    // Tools are specified on the PromptRunner
    return context.ai().withDefaultLlm()
        .withToolGroup(CoreToolGroups.WEB)  // Add web search tools
        .createObject(prompt, RelevantNewsStories.class);
}
----

Kotlin::
+
[source,kotlin]
----
@Action
internal fun findNewsStories(
    person: StarPerson,
    horoscope: Horoscope,
    context: OperationContext,
): RelevantNewsStories =
    context.ai().withDefaultLlm()
        .withToolGroup(CoreToolGroups.WEB)  // Add web search tools
        .withToolGroup(CoreToolGroups.BROWSER_AUTOMATION)  // Add browser tools
        .createObject(
            """
            ${person.name} is an astrology believer with the sign ${person.sign}.
            Their horoscope for today is:
                <horoscope>${horoscope.summary}</horoscope>
            Given this, use web tools and generate search queries
            to find $storyCount relevant news stories summarize them in a few sentences.
            Include the URL for each story.
            Do not look for another horoscope reading or return results directly about astrology;
            find stories relevant to the reading above.
            """.trimIndent()
        )
----
====

===== Key Tool Usage Patterns

**PromptRunner Tool Methods:**
Tools are added to the `PromptRunner` fluent API using methods like `withToolGroup()`, `withTools()`, and `withToolObject()`.

**Multiple Tool Groups:**
Actions can add multiple tool groups by chaining `withToolGroup()` calls when they need different types of capabilities.

**Tool-Aware Prompts:**
Prompts should explicitly instruct the LLM to use the available tools.
For example, "use web tools and generate search queries" clearly directs the LLM to utilize the web search capabilities.

===== Additional PromptRunner Examples

[source,kotlin]
----
// Add tool groups to a specific prompt
context.ai().withAutoLlm().withToolGroup(CoreToolGroups.WEB).create(
    """
    Given the topic, generate a detailed report using web research.

    # Topic
    ${reportRequest.topic}
    """.trimIndent()
)

// Add multiple tool groups
context.ai().withDefaultLlm()
    .withToolGroup(CoreToolGroups.WEB)
    .withToolGroup(CoreToolGroups.MATH)
    .createObject("Calculate stock performance with web data", StockReport::class)
----

**Adding Tool Objects with @LlmTool Methods:**

You can also provide domain objects with `@LlmTool` methods directly to specific prompts:

[source,java]
----
context.ai()
    .withDefaultLlm()
    .withToolObject(jokerTool)
    .createObject("Create a UserInput object for fun", UserInput.class);

// Add tool object with filtering and custom naming strategy
context.ai()
    .withDefaultLlm()
    .withToolObject(
        ToolObject(calculatorService)
            .withNamingStrategy { "calc_$it" }
            .withFilter { methodName -> methodName.startsWith("compute") }
    ).createObject("Perform calculations", Result.class);
----

**Available PromptRunner Tool Methods:**

- `withToolGroup(String)`: Add a single tool group by name
- `withToolGroup(ToolGroup)`: Add a specific ToolGroup instance
- `withToolGroups(Set<String>)`: Add multiple tool groups
- `withTools(vararg String)`: Convenient method to add multiple tool groups
- `withToolObject(Any)`: Add domain object with `@LlmTool` or `@Tool` methods
- `withToolObject(ToolObject)`: Add ToolObject with custom configuration
- `withTool(Tool)`: Add a framework-agnostic Tool instance
- `withTools(List<Tool>)`: Add multiple framework-agnostic Tool instances

[[reference.tools__framework-agnostic]]
==== Framework-Agnostic Tool Interface

In addition to Spring AI's `@Tool` annotation, Embabel provides its own framework-agnostic `Tool` interface in the `com.embabel.agent.api.tool` package.
This allows you to create tools that are not tied to any specific LLM framework, making your code more portable and testable.

The `Tool` interface includes nested types to avoid naming conflicts with framework-specific types:

- `Tool.Definition` - Describes the tool (name, description, input schema)
- `Tool.InputSchema` - Defines the parameters the tool accepts
- `Tool.Parameter` - A single parameter with name, type, and description
- `Tool.Result` - The result returned by a tool (text, artifact, or error)
- `Tool.Handler` - Functional interface for implementing tool logic

===== Creating Tools Programmatically

You can create tools using the `Tool.create()` factory methods:

[tabs]
====
Java::
+
[source,java]
----
// Simple tool with no parameters
Tool greetTool = Tool.create(
    "greet",
    "Greets the user",
    (input) -> Tool.Result.text("Hello!")
);

// Tool with parameters (using factory methods)
Tool addTool = Tool.create(
    "add",
    "Adds two numbers together",
    Tool.InputSchema.of(
        Tool.Parameter.integer("a", "First number"),
        Tool.Parameter.integer("b", "Second number")
    ),
    (input) -> {
        // Parse input JSON and compute result
        return Tool.Result.text("42");
    }
);

// Tool with metadata (e.g., return directly without LLM processing)
Tool directTool = Tool.create(
    "lookup",
    "Looks up data directly",
    Tool.Metadata.create(true), // returnDirect = true
    (input) -> Tool.Result.text("Direct result")
);
----

Kotlin::
+
[source,kotlin]
----
// Simple tool with no parameters
val greetTool = Tool.of(
    name = "greet",
    description = "Greets the user"
) { _ ->
    Tool.Result.text("Hello!")
}

// Tool with parameters (using factory methods)
val addTool = Tool.of(
    name = "add",
    description = "Adds two numbers together",
    inputSchema = Tool.InputSchema.of(
        Tool.Parameter.integer("a", "First number"),
        Tool.Parameter.integer("b", "Second number")
    )
) { input ->
    // Parse input JSON and compute result
    Tool.Result.text("42")
}

// Tool with metadata
val directTool = Tool.of(
    name = "lookup",
    description = "Looks up data directly",
    metadata = Tool.Metadata(returnDirect = true)
) { _ ->
    Tool.Result.text("Direct result")
}
----
====

The `Tool.Parameter` class provides factory methods for common parameter types:

- `Tool.Parameter.string(name, description)` - String parameter
- `Tool.Parameter.string(name, description, required)` - String with optional flag
- `Tool.Parameter.string(name, description, required, enumValues)` - String with allowed values
- `Tool.Parameter.integer(name, description)` - Integer parameter
- `Tool.Parameter.double(name, description)` - Floating-point parameter

All factory methods default to `required = true`.

===== Creating Tools from Annotated Methods

Embabel provides `@LlmTool` and `@LlmTool.Param` annotations for creating tools from annotated methods.
This approach is similar to Spring AI's `@Tool` but uses Embabel's framework-agnostic abstractions.

[tabs]
====
Java::
+
[source,java]
----
public class MathService {

    @LlmTool(description = "Adds two numbers together")
    public int add(
            @LlmTool.Param(description = "First number") int a,
            @LlmTool.Param(description = "Second number") int b) {
        return a + b;
    }

    @LlmTool(description = "Multiplies two numbers")
    public int multiply(
            @LlmTool.Param(description = "First number") int a,
            @LlmTool.Param(description = "Second number") int b) {
        return a * b;
    }
}

// Create tools from all annotated methods on an instance
List<Tool> mathTools = Tool.fromInstance(new MathService());

// Or safely create tools (returns empty list if no annotations found)
List<Tool> tools = Tool.safelyFromInstance(someObject);
----

Kotlin::
+
[source,kotlin]
----
class MathService {

    @LlmTool(description = "Adds two numbers together")
    fun add(
        @LlmTool.Param(description = "First number") a: Int,
        @LlmTool.Param(description = "Second number") b: Int,
    ): Int = a + b

    @LlmTool(description = "Multiplies two numbers")
    fun multiply(
        @LlmTool.Param(description = "First number") a: Int,
        @LlmTool.Param(description = "Second number") b: Int,
    ): Int = a * b
}

// Create tools from all annotated methods on an instance
val mathTools = Tool.fromInstance(MathService())

// Or safely create tools (returns empty list if no annotations found)
val tools = Tool.safelyFromInstance(someObject)
----
====

The `@LlmTool` annotation supports:

- `name`: Tool name (defaults to method name if empty)
- `description`: Description of what the tool does (required)
- `returnDirect`: Whether to return the result directly without further LLM processing

The `@LlmTool.Param` annotation supports:

- `description`: Description of the parameter (helps the LLM understand what to provide)
- `required`: Whether the parameter is required (defaults to true)

===== Adding Framework-Agnostic Tools via PromptRunner

Use `withTool()` or `withTools()` to add framework-agnostic tools to a `PromptRunner`:

[tabs]
====
Java::
+
[source,java]
----
// Add a single tool
Tool calculatorTool = Tool.create("calculate", "Performs calculations",
    (input) -> Tool.Result.text("Result: 42"));

context.ai()
    .withDefaultLlm()
    .withTool(calculatorTool)
    .createObject("Calculate 6 * 7", MathResult.class);

// Add tools from annotated methods
List<Tool> mathTools = Tool.fromInstance(new MathService());

context.ai()
    .withDefaultLlm()
    .withTools(mathTools)
    .createObject("Add 5 and 3", MathResult.class);

// Combine with other tool sources
context.ai()
    .withDefaultLlm()
    .withToolGroup(CoreToolGroups.WEB)  // Tool group
    .withToolObject(domainObject)        // Spring AI @Tool methods
    .withTools(mathTools)                // Framework-agnostic tools
    .createObject("Research and calculate", Report.class);
----

Kotlin::
+
[source,kotlin]
----
// Add a single tool
val calculatorTool = Tool.of("calculate", "Performs calculations") { _ ->
    Tool.Result.text("Result: 42")
}

context.ai()
    .withDefaultLlm()
    .withTool(calculatorTool)
    .createObject("Calculate 6 * 7", MathResult::class.java)

// Add tools from annotated methods
val mathTools = Tool.fromInstance(MathService())

context.ai()
    .withDefaultLlm()
    .withTools(mathTools)
    .createObject("Add 5 and 3", MathResult::class.java)

// Combine with other tool sources
context.ai()
    .withDefaultLlm()
    .withToolGroup(CoreToolGroups.WEB)  // Tool group
    .withToolObject(domainObject)        // Spring AI @Tool methods
    .withTools(mathTools)                // Framework-agnostic tools
    .createObject("Research and calculate", Report::class.java)
----
====

===== Tool Results

Tools return `Tool.Result` which can be one of three types:

[source,kotlin]
----
// Text result (most common)
Tool.Result.text("The answer is 42")

// Result with an artifact (e.g., generated file, image)
Tool.Result.withArtifact("Generated report", reportBytes)

// Error result
Tool.Result.error("Failed to process request", exception)
----

===== Modifying Tool Descriptions

Tools provide `withDescription()` and `withNote()` methods to create copies with modified descriptions.
This is useful when you need to customize a tool's description for a specific context without modifying the original tool.

**withDescription(newDescription)**

Creates a new tool with a completely replaced description:

[tabs]
====
Java::
+
[source,java]
----
// Replace the entire description
Tool customTool = originalTool.withDescription("Custom description for this context");

// The original tool is unchanged
System.out.println(originalTool.getDefinition().getDescription()); // original description
System.out.println(customTool.getDefinition().getDescription());   // Custom description for this context
----

Kotlin::
+
[source,kotlin]
----
// Replace the entire description
val customTool = originalTool.withDescription("Custom description for this context")

// The original tool is unchanged
println(originalTool.definition.description) // original description
println(customTool.definition.description)   // Custom description for this context
----
====

**withNote(note)**

Creates a new tool with an appended note to the existing description:

[tabs]
====
Java::
+
[source,java]
----
// Add a note to the existing description
Tool annotatedTool = originalTool.withNote("Use this when querying large datasets");

// Result: "Original description. Use this when querying large datasets"
System.out.println(annotatedTool.getDefinition().getDescription());
----

Kotlin::
+
[source,kotlin]
----
// Add a note to the existing description
val annotatedTool = originalTool.withNote("Use this when querying large datasets")

// Result: "Original description. Use this when querying large datasets"
println(annotatedTool.definition.description)
----
====

Both methods preserve all other tool properties (name, input schema, metadata, functionality):

[tabs]
====
Java::
+
[source,java]
----
Tool original = Tool.create("calculator", "Performs calculations",
    Tool.InputSchema.of(Tool.Parameter.integer("x", "Number")),
    input -> Tool.Result.text("42"));

// Create a customized version
Tool customized = original
    .withDescription("Specialized math tool")
    .withNote("Optimized for financial calculations");

// Name and functionality unchanged
assert customized.getDefinition().getName().equals("calculator");
assert customized.call("{}").text().equals("42");
----

Kotlin::
+
[source,kotlin]
----
val original = Tool.of(
    name = "calculator",
    description = "Performs calculations",
    inputSchema = Tool.InputSchema.of(Tool.Parameter.integer("x", "Number"))
) { Tool.Result.text("42") }

// Create a customized version
val customized = original
    .withDescription("Specialized math tool")
    .withNote("Optimized for financial calculations")

// Name and functionality unchanged
check(customized.definition.name == "calculator")
check(customized.call("{}").text == "42")
----
====

===== When to Use Each Approach

|===
|Approach |Use When

|Spring AI `@Tool`
|You're comfortable with Spring AI and want IDE support for tool annotations on domain objects

|`Tool.create()` / `Tool.of()`
|You need programmatic tool creation, want framework independence, or are creating tools dynamically

|`@LlmTool` / `@LlmTool.Param`
|You prefer annotation-based tools but want Embabel's framework-agnostic abstractions

|Tool Groups
|You need to organize related tools, use MCP servers, or control tool availability at deployment time
|===

[[reference.tools__tool-decoration]]
==== Tool Decoration: Extending Tool Behavior

Embabel uses a powerful decoration pattern to extend tool behavior without modifying the underlying tool or complicating the `PromptRunner`.
A decorated tool wraps another tool, intercepting calls to add functionality like artifact capture, event publishing, or blackboard integration.

This pattern is fundamental to Embabel's architecture:

* **Subagents** use decoration to wrap agent execution as a tool
* **Asset tracking** uses decoration to capture tool outputs for chatbot interfaces
* **Blackboard publishing** uses decoration to make tool results available to other actions
* **Event streaming** uses decoration to publish tool calls to external systems
* Internal platform features like observability and exception handling also use decoration

===== The DelegatingTool Interface

All tool decorators implement `DelegatingTool`:

[tabs]
====
Java::
+
[source,java]
----
public interface DelegatingTool extends Tool {
    Tool getDelegate();
}
----
Kotlin::
+
[source,kotlin]
----
interface DelegatingTool : Tool {
    val delegate: Tool
}
----
====

This allows decorators to be unwrapped when needed, and enables chaining multiple decorators.

===== ArtifactSinkingTool: Capturing Tool Outputs

`ArtifactSinkingTool` captures artifacts from `Tool.Result.WithArtifact` results and sends them to a sink.
This is the foundation for making structured tool outputs available elsewhere.

[tabs]
====
Java::
+
[source,java]
----
// Capture all artifacts and publish to blackboard
Tool wrapped = Tool.publishToBlackboard(myTool);

// Capture specific types
Tool wrapped = Tool.publishToBlackboard(myTool, SearchResult.class);

// With filtering and transformation
Tool wrapped = Tool.publishToBlackboard(
    myTool,
    SearchResult.class,
    result -> result.getScore() > 0.5,  // filter
    result -> result.getDocument()       // transform
);

// Capture to a custom sink
Tool wrapped = Tool.sinkArtifacts(myTool, SearchResult.class, mySink);
----
Kotlin::
+
[source,kotlin]
----
// Capture all artifacts and publish to blackboard
val wrapped = Tool.publishToBlackboard(myTool)

// Capture specific types
val wrapped = Tool.publishToBlackboard(myTool, SearchResult::class.java)

// With filtering and transformation
val wrapped = Tool.publishToBlackboard(
    myTool,
    SearchResult::class.java,
    { it.score > 0.5 },    // filter
    { it.document }         // transform
)

// Capture to a custom sink
val wrapped = Tool.sinkArtifacts(myTool, SearchResult::class.java, mySink)
----
====

===== Built-in Sinks

Embabel provides several `ArtifactSink` implementations:

|===
|Sink |Purpose

|`BlackboardSink`
|Publishes to the current `AgentProcess` blackboard, making artifacts available to other actions

|`ListSink`
|Collects artifacts into a list, useful for aggregating results

|`CompositeSink`
|Delegates to multiple sinks, enabling multi-destination publishing
|===

===== Creating Custom Sinks

Implement `ArtifactSink` to create custom destinations:

[tabs]
====
Java::
+
[source,java]
----
// Publish to an event stream
ArtifactSink eventSink = artifact -> {
    eventPublisher.publish(new ToolArtifactEvent(artifact));
};

// Use with any tool
Tool wrapped = Tool.sinkArtifacts(myTool, MyType.class, eventSink);
----
Kotlin::
+
[source,kotlin]
----
// Publish to an event stream
val eventSink = ArtifactSink { artifact ->
    eventPublisher.publish(ToolArtifactEvent(artifact))
}

// Use with any tool
val wrapped = Tool.sinkArtifacts(myTool, MyType::class.java, eventSink)
----
====

===== How Decoration Enables Extension

The decoration pattern lets Embabel add sophisticated behavior while keeping `PromptRunner` simple.
When you use `Subagent.ofClass(MyAgent.class)` (Java) or `Subagent.ofClass(MyAgent::class.java)` (Kotlin), Embabel creates a tool that:

1. Wraps agent execution in a `Tool.call()` method
2. Shares the parent blackboard with the child process
3. Captures the agent's result as a tool artifact

Similarly, when you configure asset tracking in a chatbot, Embabel wraps tools with `AssetAddingTool` to capture outputs as viewable assets.

This approach has key advantages:

* **Composable**: Multiple decorators can be chained
* **Transparent**: The underlying tool doesn't know it's wrapped
* **Extensible**: New behaviors can be added without framework changes
* **Type-safe**: Generic decorators like `ArtifactSinkingTool<T>` preserve type information

[[subagent-tool]]
==== Subagent: Agent Handoffs as Tools

A `Subagent` is a specialized `Tool` that delegates to another Embabel agent.
When the LLM invokes this tool, it runs the specified agent as a subprocess, sharing the parent process's blackboard context.
This enables composition of agents and "handoff" patterns where one agent delegates specialized tasks to another.

===== Creating Subagents

Subagent uses a fluent builder pattern. First select how to reference the agent, then specify the input type using `consuming()`:

[tabs]
====
Java::
+
[source,java]
----
// From an @Agent annotated class (most common)
Subagent.ofClass(ConcertAssembler.class).consuming(ConcertPlan.class)

// By agent name (resolved at runtime from platform)
Subagent.byName("ConcertAssembler").consuming(ConcertPlan.class)

// From an already-resolved Agent instance
Subagent.ofInstance(resolvedAgent).consuming(ConcertPlan.class)

// From an instance of an @Agent annotated class (e.g., a Spring bean)
Subagent.ofAnnotatedInstance(myAgentBean).consuming(ConcertPlan.class)
----

Kotlin::
+
[source,kotlin]
----
// From an @Agent annotated class with reified types (cleanest)
Subagent.ofClass<ConcertAssembler>().consuming<ConcertPlan>()

// From a Java class
Subagent.ofClass(ConcertAssembler::class.java).consuming(ConcertPlan::class.java)

// From a KClass
Subagent.ofClass(ConcertAssembler::class).consuming(ConcertPlan::class)

// By agent name (resolved at runtime from platform)
Subagent.byName("ConcertAssembler").consuming<ConcertPlan>()

// From an already-resolved Agent instance
Subagent.ofInstance(resolvedAgent).consuming<ConcertPlan>()

// From an instance of an @Agent annotated class (e.g., a Spring bean)
Subagent.ofAnnotatedInstance(myAgentBean).consuming<ConcertPlan>()
----
====

The `consuming()` method specifies the input type that the LLM will provide when invoking this tool.
This type is used to generate the JSON schema that guides the LLM's tool invocation.

===== Using Subagents with PromptRunner

Use `withTool()` to add a Subagent to your prompt:

[tabs]
====
Java::
+
[source,java]
----
@Action
public Concert assembleConcert(ConcertPlan plan, OperationContext context) {
    return context.ai()
        .withDefaultLlm()
        .withTool(Subagent.ofClass(PerformanceFinder.class)
                .consuming(WorksToFind.class))  // <1>
        .creating(Concert.class)
        .fromPrompt("Assemble a concert based on: " + plan);
}
----

Kotlin::
+
[source,kotlin]
----
@Action
fun assembleConcert(plan: ConcertPlan, context: OperationContext): Concert {
    return context.ai()
        .withDefaultLlm()
        .withTool(Subagent.ofClass<PerformanceFinder>()
                .consuming<WorksToFind>())  // <1>
        .creating(Concert::class.java)
        .fromPrompt("Assemble a concert based on: $plan")
}
----
====

<1> The LLM can now invoke `PerformanceFinder` as a tool, providing `WorksToFind` input to delegate the performance search task.

===== Subagent with Asset Tracking

For chat applications that track assets, wrap the Subagent with `AssetAddingTool` to automatically track returned artifacts:

[tabs]
====
Java::
+
[source,java]
----
@Action
public Concert assembleConcert(ConcertPlan plan, OperationContext context) {
    var subagent = Subagent.ofClass(PerformanceFinder.class)
            .consuming(WorksToFind.class);
    var trackedSubagent = assetTracker.addReturnedAssets(subagent);  // <1>

    return context.ai()
        .withDefaultLlm()
        .withTool(trackedSubagent)
        .creating(Concert.class)
        .fromPrompt("Assemble a concert based on: " + plan);
}

// With filtering - only track certain assets
var trackedSubagent = assetTracker.addReturnedAssets(subagent, asset ->
    asset instanceof Performance  // Only track Performance assets
);
----

Kotlin::
+
[source,kotlin]
----
@Action
fun assembleConcert(plan: ConcertPlan, context: OperationContext): Concert {
    val subagent = Subagent.ofClass<PerformanceFinder>()
            .consuming<WorksToFind>()
    val trackedSubagent = assetTracker.addReturnedAssets(subagent)  // <1>

    return context.ai()
        .withDefaultLlm()
        .withTool(trackedSubagent)
        .creating(Concert::class.java)
        .fromPrompt("Assemble a concert based on: $plan")
}

// With filtering - only track certain assets
val trackedSubagent = assetTracker.addReturnedAssets(subagent) { asset ->
    asset is Performance  // Only track Performance assets
}
----
====

<1> Wrap with `addReturnedAssets()` to track artifacts returned by the subagent.

===== Input Type and JSON Schema

The input type you specify with `consuming()` determines the JSON schema that the LLM sees when invoking the tool.

For example:

[source,java]
----
// The input type
public record WorksToFind(List<String> composers, String era, int maxResults) {}

// Create the subagent with explicit input type
Subagent.ofClass(PerformanceFinder.class).consuming(WorksToFind.class)
----

The Subagent tool will:

* Use "PerformanceFinder" as the tool name (from `@Agent` annotation)
* Use "Finds performances" as the tool description (from `@Agent` annotation)
* Generate a JSON schema from `WorksToFind`

**From the LLM's perspective, a Subagent is just another tool.**
The calling LLM sees the JSON schema for `WorksToFind` and can populate it directly:

[source,json]
----
{
  "composers": ["Mozart", "Beethoven"],
  "era": "Classical",
  "maxResults": 5
}
----

When the tool is invoked, Subagent deserializes this JSON into a `WorksToFind` object and passes it to the target agent.
The input type should match the first non-injected parameter of the agent's entry-point action.

===== Blackboard Sharing

When a Subagent runs, it receives a **spawned blackboard** from the parent process.
This means:

* The subagent can read objects from the parent's blackboard
* Objects added by the subagent are available to the parent after the subagent completes
* The subagent operates in its own process context but shares state appropriately

===== When to Use Subagent

|===
|Scenario |Recommendation

|Complex specialized task that has its own multi-action workflow
|Use Subagent - the target agent can plan and execute multiple steps

|Simple tool call with deterministic logic
|Use a regular `@LlmTool` method instead

|LLM-orchestrated mini-workflow with sub-tools
|Consider <<reference.tools__agentic-tools,AgenticTool>> which operates at the tool level

|Need the full power of GOAP planning for the subtask
|Subagent is ideal - the target agent uses its own planner
|===

[[reference.tools__agentic-tools]]
==== Agentic Tools

An *agentic tool* is a tool that uses an LLM to orchestrate other tools.
Unlike a regular tool which executes deterministic logic, an agentic tool delegates to an LLM that decides which sub-tools to call based on a prompt.

This pattern is useful for encapsulating a mini-orchestration as a single tool that can be used in larger workflows.

===== When to Use Agentic Tools

Agentic tools are appropriate when:

* You have a set of related tools that work together
* The orchestration logic is simple enough that an LLM can handle it with a prompt
* You want to expose a high-level capability as a single tool

IMPORTANT: For complex workflows with defined outputs, branching logic, loops, or state management, use Embabel's <<reference.planners,GOAP planner>>, <<reference.planners__utility,Utility AI>>, or <<reference.states,@State workflows>> instead.
These provide deterministic, typesafe planning that is far more powerful and predictable than LLM-driven orchestration.

===== Creating Agentic Tools

Create agentic tools using the constructor and fluent `with*` methods:

[tabs]
====
Java::
+
[source,java]
----
// Create sub-tools
Tool addTool = Tool.create("add", "Adds two numbers", input -> {
    // Parse JSON input and compute result
    return Tool.Result.text("5");
});

Tool multiplyTool = Tool.create("multiply", "Multiplies two numbers", input -> {
    return Tool.Result.text("6");
});

// Create the agentic tool
AgenticTool mathOrchestrator = new AgenticTool("math-orchestrator", "Orchestrates math operations")
    .withTools(addTool, multiplyTool)
    .withLlm(LlmOptions.withModel("gpt-4"))
    .withSystemPrompt("Use the available tools to solve the given math problem");

// Use it like any other tool
context.ai()
    .withDefaultLlm()
    .withTool(mathOrchestrator)
    .generateText("What is 5 + 3 * 2?");
----

Kotlin::
+
[source,kotlin]
----
// Create sub-tools
val addTool = Tool.of("add", "Adds two numbers") { input ->
    // Parse JSON input and compute result
    Tool.Result.text("5")
}

val multiplyTool = Tool.of("multiply", "Multiplies two numbers") { input ->
    Tool.Result.text("6")
}

// Create the agentic tool
val mathOrchestrator = AgenticTool("math-orchestrator", "Orchestrates math operations")
    .withTools(addTool, multiplyTool)
    .withLlm(LlmOptions(model = "gpt-4"))
    .withSystemPrompt("Use the available tools to solve the given math problem")

// Use it like any other tool
context.ai()
    .withDefaultLlm()
    .withTool(mathOrchestrator)
    .generateText("What is 5 + 3 * 2?")
----
====

TIP: The `withSystemPrompt` call is optional.
By default, `AgenticTool` generates a system prompt from the tool's description: _"You are an intelligent agent that can use tools to help you complete tasks.
Use the provided tools to perform the following task: {description}"_.
Only call `withSystemPrompt` if you need custom orchestration instructions.

===== Defining Input Parameters

IMPORTANT: You must define input parameters for your `AgenticTool` so the LLM knows what arguments to pass when calling it.
Without parameters, the LLM won't know what input format to use.

Use the `withParameter` method with `Tool.Parameter` factory methods for concise parameter definitions:

[tabs]
====
Java::
+
[source,java]
----
// Research tool that requires a topic parameter
AgenticTool researcher = new AgenticTool("researcher", "Research a topic thoroughly")
    .withParameter(Tool.Parameter.string("topic", "The topic to research"))
    .withToolObjects(new SearchTools(), new SummarizerTools());

// Calculator with multiple parameters
AgenticTool calculator = new AgenticTool("smart-calculator", "Perform complex calculations")
    .withParameter(Tool.Parameter.string("expression", "Mathematical expression to evaluate"))
    .withParameter(Tool.Parameter.integer("precision", "Decimal places for result", false))  // optional
    .withToolObject(new MathTools());
----

Kotlin::
+
[source,kotlin]
----
// Research tool that requires a topic parameter
val researcher = AgenticTool("researcher", "Research a topic thoroughly")
    .withParameter(Tool.Parameter.string("topic", "The topic to research"))
    .withToolObjects(SearchTools(), SummarizerTools())

// Calculator with multiple parameters
val calculator = AgenticTool("smart-calculator", "Perform complex calculations")
    .withParameter(Tool.Parameter.string("expression", "Mathematical expression to evaluate"))
    .withParameter(Tool.Parameter.integer("precision", "Decimal places for result", required = false))  // optional
    .withToolObject(MathTools())
----
====

Available parameter factory methods:

- `Tool.Parameter.string(name, description, required?)` - String parameter
- `Tool.Parameter.integer(name, description, required?)` - Integer parameter
- `Tool.Parameter.double(name, description, required?)` - Floating-point parameter

All factory methods default to `required = true`.
Set `required = false` for optional parameters.

===== Creating Agentic Tools from Annotated Objects

Use `withToolObject` or `withToolObjects` to add tools from objects with `@LlmTool`-annotated methods:

[tabs]
====
Java::
+
[source,java]
----
// Tool classes with @LlmTool methods
public class SearchTools {
    @LlmTool(description = "Search the web")
    public String search(String query) { return "Results for: " + query; }
}

public class CalculatorTools {
    @LlmTool(description = "Add two numbers")
    public int add(int a, int b) { return a + b; }

    @LlmTool(description = "Multiply two numbers")
    public int multiply(int a, int b) { return a * b; }
}

// Create agentic tool with tools from multiple objects
// Uses default system prompt based on description
AgenticTool assistant = new AgenticTool("assistant", "Multi-capability assistant")
    .withToolObjects(new SearchTools(), new CalculatorTools());

// With LLM options and custom system prompt
AgenticTool smartAssistant = new AgenticTool("smart-assistant", "Smart assistant")
    .withToolObjects(new SearchTools(), new CalculatorTools())
    .withLlm(LlmOptions.withModel("gpt-4"))
    .withSystemPrompt("Use tools intelligently");
----

Kotlin::
+
[source,kotlin]
----
// Tool classes with @LlmTool methods
class SearchTools {
    @LlmTool(description = "Search the web")
    fun search(query: String): String = "Results for: $query"
}

class CalculatorTools {
    @LlmTool(description = "Add two numbers")
    fun add(a: Int, b: Int): Int = a + b

    @LlmTool(description = "Multiply two numbers")
    fun multiply(a: Int, b: Int): Int = a * b
}

// Create agentic tool with tools from multiple objects
// Uses default system prompt based on description
val assistant = AgenticTool("assistant", "Multi-capability assistant")
    .withToolObjects(SearchTools(), CalculatorTools())

// With LLM options and custom system prompt
val smartAssistant = AgenticTool("smart-assistant", "Smart assistant")
    .withToolObjects(SearchTools(), CalculatorTools())
    .withLlm(LlmOptions(model = "gpt-4"))
    .withSystemPrompt("Use tools intelligently")
----
====

Objects without `@LlmTool` methods are silently ignored, allowing you to mix objects safely.

===== Agentic Tools with Spring Dependency Injection

Agentic tools can encapsulate stateful services via dependency injection:

[source,kotlin]
----
@Component
class ResearchOrchestrator(
    private val webSearchService: WebSearchService,
    private val summarizerService: SummarizerService,
) {
    @LlmTool(description = "Search the web for information")
    fun search(query: String): List<SearchResult> =
        webSearchService.search(query)

    @LlmTool(description = "Summarize text content")
    fun summarize(content: String): String =
        summarizerService.summarize(content)
}

// In your configuration
@Configuration
class ToolConfiguration {

    @Bean
    fun researchTool(orchestrator: ResearchOrchestrator): AgenticTool =
        AgenticTool("research-assistant", "Research topics using web search and summarization")
            .withToolObject(orchestrator)
            .withLlm(LlmOptions(role = "smart"))
            // Uses default system prompt based on description
}
----

===== How Agentic Tools Execute

When an agentic tool's `call()` method is invoked:

1. The tool retrieves the current `AgentProcess` context
2. It configures a `PromptRunner` with the specified `LlmOptions`
3. It adds all sub-tools to the prompt runner
4. It executes the prompt with the input, allowing the LLM to orchestrate the sub-tools
5. The final LLM response is returned as the tool result

This means agentic tools create a nested LLM interaction: the outer LLM decides to call the agentic tool, then the inner LLM orchestrates the sub-tools.

===== Modifying Agentic Tools

Use the `with*` methods to create modified copies:

[source,kotlin]
----
val base = AgenticTool("base", "Base orchestrator")
    .withTools(tool1)
    .withSystemPrompt("Original prompt")

// Create copies with modifications
val withNewLlm = base.withLlm(LlmOptions(model = "gpt-4"))
val withMoreTools = base.withTools(tool2, tool3)
val withNewPrompt = base.withSystemPrompt("Updated prompt")

// Add input parameters
val withParams = base.withParameter(Tool.Parameter.string("query", "Search query"))

// Add tools from an object with @LlmTool methods
val withAnnotatedTools = base.withToolObject(calculatorService)

// Add tools from multiple objects
val withMultipleObjects = base.withToolObjects(searchService, calculatorService)

// Dynamic system prompt based on AgentProcess context
val withDynamicPrompt = base.withSystemPromptCreator { agentProcess ->
    val userId = agentProcess.blackboard.get("userId", String::class.java)
    "Process requests for user $userId using the available tools"
}
----

The available modification methods are:

- `withParameter(Tool.Parameter)`: Add an input parameter (use `Tool.Parameter.string()`, `.integer()`, `.double()`)
- `withLlm(LlmOptions)`: Set LLM configuration
- `withTools(vararg Tool)`: Add additional Tool instances
- `withToolObject(Any)`: Add tools from an object with `@LlmTool` methods
- `withToolObjects(vararg Any)`: Add tools from multiple annotated objects
- `withSystemPrompt(String)`: Set a fixed system prompt
- `withSystemPromptCreator((AgentProcess) -> String)`: Set a dynamic prompt based on runtime context
- `withCaptureNestedArtifacts(Boolean)`: Control whether artifacts from nested `AgenticTool` calls are captured (default: `false`)

[[reference.tools__agentic-tools-artifact-capture]]
===== Controlling Artifact Capture in Nested Agentic Tools

When an `AgenticTool` orchestrates other tools, those sub-tools may return artifacts (via `Tool.Result.WithArtifact`).
By default, artifacts from nested `AgenticTool` calls are *not* captured—only the final result from the outermost agentic tool is returned.

This prevents intermediate artifacts from bubbling up when you only care about the final result.
For example, if an outer `assembleConcert` tool calls an inner `findPerformances` tool, you typically want only the final `Concert` artifact, not all the intermediate `Performance` artifacts.

Use `withCaptureNestedArtifacts(true)` if you need to capture artifacts from nested agentic tools:

[tabs]
====
Java::
+
[source,java]
----
// Default: nested artifacts are NOT captured
AgenticTool concertAssembler = new AgenticTool("assembleConcert", "Assemble a concert program")
    .withTools(findPerformancesTool, createConcertTool);
// Only the Concert artifact from createConcert is returned

// Opt-in: capture all nested artifacts
AgenticTool fullCapture = concertAssembler.withCaptureNestedArtifacts(true);
// Both Performance artifacts from findPerformances AND Concert from createConcert are captured
----

Kotlin::
+
[source,kotlin]
----
// Default: nested artifacts are NOT captured
val concertAssembler = AgenticTool("assembleConcert", "Assemble a concert program")
    .withTools(findPerformancesTool, createConcertTool)
// Only the Concert artifact from createConcert is returned

// Opt-in: capture all nested artifacts
val fullCapture = concertAssembler.withCaptureNestedArtifacts(true)
// Both Performance artifacts from findPerformances AND Concert from createConcert are captured
----
====

IMPORTANT: This setting only affects artifacts from nested `AgenticTool` calls.
Artifacts from regular (non-agentic) tools are always captured.

[[reference.tools__artifact-filtering]]
===== Filtering Artifacts for Asset Tracking

When using tools with an `AssetTracker` (common in chat applications), you can filter which artifacts become tracked assets.
The `addReturnedAssets` and `addAnyReturnedAssets` methods accept a `Predicate<Asset>` filter that works with both Java and Kotlin:

[tabs]
====
Java::
+
[source,java]
----
// Track only assets that pass the filter
Tool wrapped = assetTracker.addReturnedAssets(concertTool, asset -> {
    // Only track concerts with at least 3 works
    return asset instanceof Concert concert && concert.getWorks().size() >= 3;
});

// Apply the same filter to multiple tools
List<Tool> wrappedTools = assetTracker.addAnyReturnedAssets(
    List.of(tool1, tool2, tool3),
    asset -> asset.getId().startsWith("important-")
);
----

Kotlin::
+
[source,kotlin]
----
// Track only assets that pass the filter
val wrapped = assetTracker.addReturnedAssets(concertTool) { asset ->
    // Only track concerts with at least 3 works
    asset is Concert && asset.works.size >= 3
}

// Apply the same filter to multiple tools
val wrappedTools = assetTracker.addAnyReturnedAssets(
    listOf(tool1, tool2, tool3)
) { asset -> asset.id.startsWith("important-") }
----
====

The filter is applied after type matching, so you can use type-specific criteria to decide which artifacts are worth tracking.

[[reference.tools__agentic-tools-migration]]
===== Migration from Other Frameworks

If you're coming from frameworks like LangChain or Google ADK, `AgenticTool` provides a familiar pattern similar to their "supervisor" architectures:

|===
|Framework |Pattern |Embabel Equivalent

|LangChain/LangGraph
|Supervisor agent with worker agents
|`AgenticTool` with sub-tools

|Google ADK
|Coordinator with `sub_agents` / `AgentTool`
|`AgenticTool` with sub-tools
|===

The key differences:

* **Tool-centric**: Embabel's agentic tools operate at the tool level, not the agent level.
They're lightweight and can be mixed freely with regular tools.
* **Simpler model**: No graph-based workflows or explicit Sequential/Parallel/Loop patterns—just LLM-driven orchestration.
* **Composable**: An agentic tool is still "just a tool" that can be used anywhere tools are accepted.

However, for anything beyond simple orchestration, Embabel offers far more powerful alternatives:

|===
|Scenario |Use This Instead

|Business processes with defined outputs
|<<reference.planners,GOAP planner>> - deterministic, goal-oriented planning with preconditions and effects

|Exploration and event-driven systems
|<<reference.planners__utility,Utility AI>> - selects highest-value action at each step

|Branching, looping, or stateful workflows
|<<reference.states,@State workflows>> - typesafe state machines with GOAP planning within each state
|===

These provide *deterministic, typesafe planning* that is far more predictable and powerful than supervisor-style LLM orchestration.
Use `AgenticTool` for simple cases or as a migration stepping stone; graduate to GOAP, Utility, or @State for production workflows where predictability matters.

TIP: For supervisor-style orchestration with typed outputs and full blackboard state management, see <<reference.planners__supervisor-invocation,SupervisorInvocation>>.
It operates at a higher level than `AgenticTool`, orchestrating `@Action` methods rather than `Tool` instances, and produces typed goal objects with currying support.

[[reference.tools__matryoshka]]
==== MatryoshkaTool: Progressive Tool Disclosure

[quote,Augustus De Morgan]
____
Great fleas have little fleas upon their backs to bite 'em, +
And little fleas have lesser fleas, and so ad infinitum. +
And the great fleas themselves, in turn, have greater fleas to go on; +
While these again have greater still, and greater still, and so on.
____

A `MatryoshkaTool` is a special tool that presents a high-level description to the LLM and, when invoked, exposes its inner tools.
Named after Russian nesting dolls, this pattern enables *progressive tool disclosure* - presenting a simplified interface initially, then revealing more granular tools on demand.

===== When to Use MatryoshkaTool

MatryoshkaTool is useful when:

* You have many related tools that might overwhelm the LLM with choices
* You want to group tools by category (e.g., "database operations", "file operations")
* You want the LLM to express intent before revealing detailed options
* You need to reduce token usage for tool descriptions

===== Creating a Simple MatryoshkaTool

The simplest form exposes all inner tools when invoked:

[tabs]
====
Java::
+
[source,java]
----
import com.embabel.agent.api.tool.MatryoshkaTool;
import com.embabel.agent.api.tool.Tool;

// Create inner tools
Tool queryTool = Tool.create("query_table", "Execute a SQL query",
    Tool.InputSchema.of(Tool.Parameter.string("sql", "The SQL query to execute")),
    input -> Tool.Result.text("{\"rows\": 5}")
);

Tool insertTool = Tool.create("insert_record", "Insert a new record",
    Tool.InputSchema.of(Tool.Parameter.string("table", "Table name")),
    input -> Tool.Result.text("{\"id\": 123}")
);

Tool deleteTool = Tool.create("delete_record", "Delete a record",
    Tool.InputSchema.of(Tool.Parameter.integer("id", "Record ID to delete")),
    input -> Tool.Result.text("{\"deleted\": true}")
);

// Create the MatryoshkaTool facade
MatryoshkaTool databaseTool = MatryoshkaTool.of(
    "database_operations",
    "Use this tool to work with the database. Invoke to see specific operations.",
    List.of(queryTool, insertTool, deleteTool)
);
----

Kotlin::
+
[source,kotlin]
----
import com.embabel.agent.api.tool.MatryoshkaTool
import com.embabel.agent.api.tool.Tool

// Create inner tools
val queryTool = Tool.of(
    name = "query_table",
    description = "Execute a SQL query",
    inputSchema = Tool.InputSchema.of(Tool.Parameter.string("sql", "The SQL query to execute"))
) { input -> Tool.Result.text("""{"rows": 5}""") }

val insertTool = Tool.of(
    name = "insert_record",
    description = "Insert a new record",
    inputSchema = Tool.InputSchema.of(Tool.Parameter.string("table", "Table name"))
) { input -> Tool.Result.text("""{"id": 123}""") }

val deleteTool = Tool.of(
    name = "delete_record",
    description = "Delete a record",
    inputSchema = Tool.InputSchema.of(Tool.Parameter.integer("id", "Record ID to delete"))
) { input -> Tool.Result.text("""{"deleted": true}""") }

// Create the MatryoshkaTool facade
val databaseTool = MatryoshkaTool.of(
    name = "database_operations",
    description = "Use this tool to work with the database. Invoke to see specific operations.",
    innerTools = listOf(queryTool, insertTool, deleteTool)
)
----
====

===== Category-Based Tool Selection

Use `byCategory` to expose different tools based on the category the LLM selects:

[tabs]
====
Java::
+
[source,java]
----
import com.embabel.agent.api.tool.MatryoshkaTool;
import java.util.Map;

// Define tools by category
Map<String, List<Tool>> toolsByCategory = Map.of(
    "read", List.of(readFileTool, listDirectoryTool, searchFilesTool),
    "write", List.of(writeFileTool, deleteFileTool, moveFileTool)
);

// Create category-based MatryoshkaTool
MatryoshkaTool fileTool = MatryoshkaTool.byCategory(
    "file_operations",
    "File operations. Pass category: 'read' for reading files, 'write' for modifying files.",
    toolsByCategory
);

// The tool's schema automatically includes the category as an enum parameter
// When invoked with {"category": "read"}, only read tools are exposed
// When invoked with {"category": "write"}, only write tools are exposed
----

Kotlin::
+
[source,kotlin]
----
import com.embabel.agent.api.tool.MatryoshkaTool

// Define tools by category
val toolsByCategory = mapOf(
    "read" to listOf(readFileTool, listDirectoryTool, searchFilesTool),
    "write" to listOf(writeFileTool, deleteFileTool, moveFileTool)
)

// Create category-based MatryoshkaTool
val fileTool = MatryoshkaTool.byCategory(
    name = "file_operations",
    description = "File operations. Pass category: 'read' for reading files, 'write' for modifying files.",
    toolsByCategory = toolsByCategory
)

// The tool's schema automatically includes the category as an enum parameter
// When invoked with {"category": "read"}, only read tools are exposed
// When invoked with {"category": "write"}, only write tools are exposed
----
====

===== Custom Selection Logic

For more complex selection logic, use `selectable`:

[tabs]
====
Java::
+
[source,java]
----
import com.embabel.agent.api.tool.MatryoshkaTool;
import com.fasterxml.jackson.databind.ObjectMapper;

List<Tool> allTools = List.of(basicTool, advancedTool, adminTool);

MatryoshkaTool permissionBasedTool = MatryoshkaTool.selectable(
    "api_operations",
    "API operations. Pass 'accessLevel': 'basic', 'advanced', or 'admin'.",
    allTools,
    Tool.InputSchema.of(
        Tool.Parameter.string("accessLevel", "Access level for operations",
            true, List.of("basic", "advanced", "admin"))
    ),
    true,  // removeOnInvoke
    input -> {
        // Custom selection logic
        try {
            ObjectMapper mapper = new ObjectMapper();
            Map<String, Object> params = mapper.readValue(input, Map.class);
            String level = (String) params.get("accessLevel");
            return switch (level) {
                case "basic" -> List.of(basicTool);
                case "advanced" -> List.of(basicTool, advancedTool);
                case "admin" -> allTools;
                default -> List.of(basicTool);
            };
        } catch (Exception e) {
            return List.of(basicTool);
        }
    }
);
----

Kotlin::
+
[source,kotlin]
----
import com.embabel.agent.api.tool.MatryoshkaTool
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper

val allTools = listOf(basicTool, advancedTool, adminTool)

val permissionBasedTool = MatryoshkaTool.selectable(
    name = "api_operations",
    description = "API operations. Pass 'accessLevel': 'basic', 'advanced', or 'admin'.",
    innerTools = allTools,
    inputSchema = Tool.InputSchema.of(
        Tool.Parameter.string("accessLevel", "Access level for operations",
            required = true, enumValues = listOf("basic", "advanced", "admin"))
    ),
) { input ->
    // Custom selection logic
    val mapper = jacksonObjectMapper()
    val params = mapper.readValue(input, Map::class.java)
    when (params["accessLevel"]) {
        "basic" -> listOf(basicTool)
        "advanced" -> listOf(basicTool, advancedTool)
        "admin" -> allTools
        else -> listOf(basicTool)
    }
}
----
====

===== Keeping the Facade Available

By default, a MatryoshkaTool is removed after invocation (replaced by its inner tools).
Set `removeOnInvoke = false` to keep the facade available for re-invocation with different arguments:

[tabs]
====
Java::
+
[source,java]
----
// Facade stays available after invocation
MatryoshkaTool persistentTool = MatryoshkaTool.of(
    "operations",
    "Operations. Invoke multiple times with different needs.",
    allTools,
    false  // removeOnInvoke = false
);
----

Kotlin::
+
[source,kotlin]
----
// Facade stays available after invocation
val persistentTool = MatryoshkaTool.of(
    name = "operations",
    description = "Operations. Invoke multiple times with different needs.",
    innerTools = allTools,
    removeOnInvoke = false
)
----
====

===== Enabling MatryoshkaTool in the Tool Loop

MatryoshkaTool is **enabled by default** when using Embabel's tool loop.
The `ToolInjectionStrategy.DEFAULT` includes `MatryoshkaToolInjectionStrategy`, so no additional configuration is needed.

If you need to combine with custom strategies, use `ChainedToolInjectionStrategy`:

[tabs]
====
Java::
+
[source,java]
----
import com.embabel.agent.spi.loop.ChainedToolInjectionStrategy;

// Combine MatryoshkaTool support with custom strategies
ChainedToolInjectionStrategy combined =
    ChainedToolInjectionStrategy.withMatryoshka(customStrategy1, customStrategy2);
----

Kotlin::
+
[source,kotlin]
----
import com.embabel.agent.spi.loop.ChainedToolInjectionStrategy

// Combine MatryoshkaTool support with custom strategies
val combined = ChainedToolInjectionStrategy.withMatryoshka(customStrategy1, customStrategy2)
----
====

===== How MatryoshkaTool Works

1. **Initial state**: The LLM sees only the facade tool (e.g., "database_operations")
2. **LLM invokes**: The LLM calls the facade with optional arguments
3. **Strategy evaluates**: `MatryoshkaToolInjectionStrategy` detects the invocation
4. **Tools replaced**: The facade is removed (if `removeOnInvoke` is true) and inner tools are added
5. **Continue**: The LLM now sees and can use the specific inner tools

This flow reduces the initial tool set complexity while allowing the LLM to access detailed tools when it needs them.

===== Context Preservation and Usage Notes

When a MatryoshkaTool is expanded, its child tools replace the facade.
Without context preservation, the LLM would lose important information about _why_ these tools are grouped together.

For example, a "spotify_search" tool containing `vector_search`, `text_search`, and `regex_search` would expand to just three generic search tools - the LLM wouldn't know these are specifically for searching Spotify music data.

Embabel solves this by automatically injecting a **context tool** alongside the child tools.
This context tool:

* Preserves the parent's description ("Search Spotify for music data")
* Lists the available child tools
* Includes optional usage notes (via `childToolUsageNotes`)

The `childToolUsageNotes` parameter provides guidance on when and how to use the child tools.
This guidance appears **once** in the context tool rather than being duplicated in each child tool's description:

[tabs]
====
Java::
+
[source,java]
----
MatryoshkaTool spotifySearch = MatryoshkaTool.of(
    "spotify_search",
    "Search Spotify for music data including artists, albums, and tracks.",
    List.of(vectorSearchTool, textSearchTool, regexSearchTool),
    true,  // removeOnInvoke
    "Try vector search first for semantic queries like 'upbeat jazz'. " +
    "Use text search for exact artist or album names. " +
    "Use regex search for pattern matching on metadata."
);
----

Kotlin::
+
[source,kotlin]
----
val spotifySearch = MatryoshkaTool.of(
    name = "spotify_search",
    description = "Search Spotify for music data including artists, albums, and tracks.",
    innerTools = listOf(vectorSearchTool, textSearchTool, regexSearchTool),
    childToolUsageNotes = """
        Try vector search first for semantic queries like 'upbeat jazz'.
        Use text search for exact artist or album names.
        Use regex search for pattern matching on metadata.
    """.trimIndent()
)
----
====

After the LLM invokes `spotify_search`, it will see:

* `vector_search` - the actual search tool
* `text_search` - the actual search tool
* `regex_search` - the actual search tool
* `spotify_search_context` - context tool with description and usage notes

The context tool's description includes the original purpose and available tools.
When called, it returns full details about each child tool plus the usage notes - providing a single reference point without polluting individual tool descriptions.

===== Annotation-Based MatryoshkaTool

For a more declarative approach, use the `@MatryoshkaTools` class annotation combined with `@LlmTool` method annotations:

[tabs]
====
Java::
+
[source,java]
----
import com.embabel.agent.api.annotation.MatryoshkaTools;
import com.embabel.agent.api.annotation.LlmTool;

@MatryoshkaTools(
    name = "database_operations",
    description = "Database operations. Invoke to see specific tools."
)
public class DatabaseTools {

    @LlmTool(description = "Execute a SQL query")
    public QueryResult query(String sql) {
        // implementation
    }

    @LlmTool(description = "Insert a record")
    public InsertResult insert(String table, Map<String, Object> data) {
        // implementation
    }

    @LlmTool(description = "Delete a record")
    public void delete(long id) {
        // implementation
    }
}

// Create the MatryoshkaTool from the annotated class
MatryoshkaTool tool = MatryoshkaTool.fromInstance(new DatabaseTools());
----

Kotlin::
+
[source,kotlin]
----
import com.embabel.agent.api.annotation.MatryoshkaTools
import com.embabel.agent.api.annotation.LlmTool

@MatryoshkaTools(
    name = "database_operations",
    description = "Database operations. Invoke to see specific tools."
)
class DatabaseTools {

    @LlmTool(description = "Execute a SQL query")
    fun query(sql: String): QueryResult {
        // implementation
    }

    @LlmTool(description = "Insert a record")
    fun insert(table: String, data: Map<String, Any>): InsertResult {
        // implementation
    }

    @LlmTool(description = "Delete a record")
    fun delete(id: Long) {
        // implementation
    }
}

// Create the MatryoshkaTool from the annotated class
val tool = MatryoshkaTool.fromInstance(DatabaseTools())
----
====

You can also specify `childToolUsageNotes` in the annotation to provide guidance on using the child tools:

[tabs]
====
Java::
+
[source,java]
----
@MatryoshkaTools(
    name = "music_search",
    description = "Search music database for artists, albums, and tracks",
    childToolUsageNotes = "Try vector search first for semantic queries. " +
        "Use text search for exact artist names."
)
public class MusicSearchTools {

    @LlmTool(description = "Semantic search using embeddings")
    public List<Track> vectorSearch(String query) {
        // implementation
    }

    @LlmTool(description = "Exact match text search")
    public List<Track> textSearch(String query) {
        // implementation
    }
}
----

Kotlin::
+
[source,kotlin]
----
@MatryoshkaTools(
    name = "music_search",
    description = "Search music database for artists, albums, and tracks",
    childToolUsageNotes = "Try vector search first for semantic queries. " +
        "Use text search for exact artist names."
)
class MusicSearchTools {

    @LlmTool(description = "Semantic search using embeddings")
    fun vectorSearch(query: String): List<Track> {
        // implementation
    }

    @LlmTool(description = "Exact match text search")
    fun textSearch(query: String): List<Track> {
        // implementation
    }
}
----
====

===== Category-Based Selection with Annotations

Add `category` to `@LlmTool` annotations to automatically create a category-based MatryoshkaTool:

[tabs]
====
Java::
+
[source,java]
----
@MatryoshkaTools(
    name = "file_operations",
    description = "File operations. Pass category: 'read' or 'write'."
)
public class FileTools {

    @LlmTool(description = "Read file contents", category = "read")
    public String readFile(String path) {
        return Files.readString(Path.of(path));
    }

    @LlmTool(description = "List directory contents", category = "read")
    public List<String> listDir(String path) {
        return Files.list(Path.of(path)).map(Path::toString).toList();
    }

    @LlmTool(description = "Write file contents", category = "write")
    public void writeFile(String path, String content) {
        Files.writeString(Path.of(path), content);
    }

    @LlmTool(description = "Delete a file", category = "write")
    public void deleteFile(String path) {
        Files.delete(Path.of(path));
    }
}

// Automatically creates category-based selection
MatryoshkaTool tool = MatryoshkaTool.fromInstance(new FileTools());
// When invoked with {"category": "read"}, only read tools are exposed
// When invoked with {"category": "write"}, only write tools are exposed
----

Kotlin::
+
[source,kotlin]
----
@MatryoshkaTools(
    name = "file_operations",
    description = "File operations. Pass category: 'read' or 'write'."
)
class FileTools {

    @LlmTool(description = "Read file contents", category = "read")
    fun readFile(path: String): String = File(path).readText()

    @LlmTool(description = "List directory contents", category = "read")
    fun listDir(path: String): List<String> = File(path).list()?.toList() ?: emptyList()

    @LlmTool(description = "Write file contents", category = "write")
    fun writeFile(path: String, content: String) {
        File(path).writeText(content)
    }

    @LlmTool(description = "Delete a file", category = "write")
    fun deleteFile(path: String) {
        File(path).delete()
    }
}

// Automatically creates category-based selection
val tool = MatryoshkaTool.fromInstance(FileTools())
// When invoked with {"category": "read"}, only read tools are exposed
// When invoked with {"category": "write"}, only write tools are exposed
----
====

===== @MatryoshkaTools Annotation Attributes

|===
|Attribute |Type |Default |Description

|`name`
|String
|Required
|Name of the facade tool the LLM will see

|`description`
|String
|Required
|Description explaining the tool category

|`removeOnInvoke`
|boolean
|`true`
|Whether to remove the facade after invocation

|`categoryParameter`
|String
|`"category"`
|Name of the parameter for category selection
|===

===== @LlmTool Category Attribute

The `category` attribute on `@LlmTool` is used when the containing class has `@MatryoshkaTools`:

- Tools with the same category are grouped together
- Tools without a category are added to all category groups plus an "all" category
- If no tools have categories, a simple (non-category-based) MatryoshkaTool is created

===== Real-World Example: Spotify Integration

Here's a real-world example from the Impromptu chatbot that uses `@MatryoshkaTools` to progressively disclose Spotify functionality:

[source,java]
----
@MatryoshkaTools(
    name = "spotify",
    description = "Access Spotify music features. Invoke this tool to enable Spotify " +
            "operations like playing music, searching tracks, managing playlists, " +
            "and controlling playback."
)
public record SpotifyTools(ImpromptuUser user, SpotifyService spotifyService) {

    @LlmTool(description = "Check if user has linked their Spotify account")
    public String checkSpotifyStatus() { /* ... */ }

    @LlmTool(description = "Get the user's Spotify playlists")
    public String getPlaylists() { /* ... */ }

    @LlmTool(description = "Search for tracks on Spotify by song name, artist, or both")
    public String searchTracks(String query) { /* ... */ }

    @LlmTool(description = "Play a track on Spotify by searching for it")
    public String playTrack(String query) { /* ... */ }

    @LlmTool(description = "Pause the current Spotify playback")
    public String pausePlayback() { /* ... */ }

    // ... more tools
}
----

With this setup:

1. The LLM initially sees a single `spotify` tool
2. When the user says "play some jazz", the LLM invokes `spotify`
3. The `spotify` facade is replaced with all the inner tools (`getPlaylists`, `searchTracks`, `playTrack`, etc.)
4. The LLM can then call `searchTracks` or `playTrack` to fulfill the request

===== Auto-Detection with Tool.fromInstance()

When you use `Tool.fromInstance()` on a class annotated with `@MatryoshkaTools`, it automatically creates a `MatryoshkaTool`:

[source,java]
----
// Auto-detects @MatryoshkaTools and creates a MatryoshkaTool
List<Tool> tools = Tool.fromInstance(new SpotifyTools(user, service));
// Returns a single MatryoshkaTool, not individual tools
----

This works seamlessly with `withToolObject()` on PromptRunner:

[source,java]
----
context.ai()
    .withToolObject(new SpotifyTools(user, spotifyService))
    .respond("Play some classical music");
// The SpotifyTools are automatically exposed as a single MatryoshkaTool facade
----

===== Nested MatryoshkaTools

MatryoshkaTools can be nested for multi-level progressive disclosure.
This enables organizing large tool collections into logical hierarchies where the LLM navigates by invoking facade tools.

====== Programmatic Nesting

Use `MatryoshkaTool.of()` to create nested hierarchies programmatically:

[tabs]
====
Java::
+
[source,java]
----
// Inner matryoshka for user management
MatryoshkaTool userManagement = MatryoshkaTool.of(
    "user_management",
    "User management operations",
    List.of(createUserTool, deleteUserTool, updateUserTool)
);

// Inner matryoshka for system config
MatryoshkaTool systemConfig = MatryoshkaTool.of(
    "system_config",
    "System configuration operations",
    List.of(updateConfigTool, backupTool, restoreTool)
);

// Outer matryoshka containing both
MatryoshkaTool adminTool = MatryoshkaTool.of(
    "admin_operations",
    "Administrative operations. Invoke to see categories.",
    List.of(userManagement, systemConfig)
);

// Flow:
// 1. LLM sees: admin_operations
// 2. LLM invokes: admin_operations -> sees: user_management, system_config
// 3. LLM invokes: user_management -> sees: createUser, deleteUser, updateUser
----

Kotlin::
+
[source,kotlin]
----
// Inner matryoshka for user management
val userManagement = MatryoshkaTool.of(
    name = "user_management",
    description = "User management operations",
    innerTools = listOf(createUserTool, deleteUserTool, updateUserTool)
)

// Inner matryoshka for system config
val systemConfig = MatryoshkaTool.of(
    name = "system_config",
    description = "System configuration operations",
    innerTools = listOf(updateConfigTool, backupTool, restoreTool)
)

// Outer matryoshka containing both
val adminTool = MatryoshkaTool.of(
    name = "admin_operations",
    description = "Administrative operations. Invoke to see categories.",
    innerTools = listOf(userManagement, systemConfig)
)

// Flow:
// 1. LLM sees: admin_operations
// 2. LLM invokes: admin_operations -> sees: user_management, system_config
// 3. LLM invokes: user_management -> sees: createUser, deleteUser, updateUser
----
====

====== Annotation-Based Nesting with Inner Classes

You can also create nested hierarchies using `@MatryoshkaTools` annotations on inner classes.
When `MatryoshkaTool.fromInstance()` is called, it automatically discovers and includes any nested inner classes that are also annotated with `@MatryoshkaTools`:

[tabs]
====
Java::
+
[source,java]
----
@MatryoshkaTools(
    name = "admin_operations",
    description = "Administrative operations. Invoke to access specific areas."
)
public class AdminTools {

    @LlmTool(description = "Get system status")
    public String getStatus() {
        return "System is healthy";
    }

    // Nested inner class - automatically discovered and included as a nested MatryoshkaTool
    @MatryoshkaTools(
        name = "user_management",
        description = "User management operations. Invoke to see specific tools."
    )
    public static class UserManagement {

        @LlmTool(description = "Create a new user")
        public String createUser(String username) { return "Created user: " + username; }

        @LlmTool(description = "Delete a user")
        public String deleteUser(String username) { return "Deleted user: " + username; }

        // Can nest even deeper
        @MatryoshkaTools(
            name = "user_permissions",
            description = "User permission operations"
        )
        public static class Permissions {

            @LlmTool(description = "Grant permission to user")
            public String grant(String user, String permission) { return "Granted"; }

            @LlmTool(description = "Revoke permission from user")
            public String revoke(String user, String permission) { return "Revoked"; }
        }
    }

    @MatryoshkaTools(
        name = "system_config",
        description = "System configuration. Invoke to see config tools."
    )
    public static class SystemConfig {

        @LlmTool(description = "Update configuration")
        public String updateConfig(String key, String value) { return "Updated"; }

        @LlmTool(description = "Backup configuration")
        public String backup() { return "Backed up"; }
    }
}

// Create the full nested hierarchy automatically
MatryoshkaTool adminTool = MatryoshkaTool.fromInstance(new AdminTools());

// Flow:
// 1. LLM sees: admin_operations
// 2. LLM invokes: admin_operations -> sees: getStatus, user_management, system_config
// 3. LLM invokes: user_management -> sees: createUser, deleteUser, user_permissions
// 4. LLM invokes: user_permissions -> sees: grant, revoke
----

Kotlin::
+
[source,kotlin]
----
@MatryoshkaTools(
    name = "admin_operations",
    description = "Administrative operations. Invoke to access specific areas."
)
class AdminTools {

    @LlmTool(description = "Get system status")
    fun getStatus(): String = "System is healthy"

    // Nested inner class - automatically discovered and included as a nested MatryoshkaTool
    @MatryoshkaTools(
        name = "user_management",
        description = "User management operations. Invoke to see specific tools."
    )
    class UserManagement {

        @LlmTool(description = "Create a new user")
        fun createUser(username: String): String = "Created user: $username"

        @LlmTool(description = "Delete a user")
        fun deleteUser(username: String): String = "Deleted user: $username"

        // Can nest even deeper
        @MatryoshkaTools(
            name = "user_permissions",
            description = "User permission operations"
        )
        class Permissions {

            @LlmTool(description = "Grant permission to user")
            fun grant(user: String, permission: String): String = "Granted"

            @LlmTool(description = "Revoke permission from user")
            fun revoke(user: String, permission: String): String = "Revoked"
        }
    }

    @MatryoshkaTools(
        name = "system_config",
        description = "System configuration. Invoke to see config tools."
    )
    class SystemConfig {

        @LlmTool(description = "Update configuration")
        fun updateConfig(key: String, value: String): String = "Updated"

        @LlmTool(description = "Backup configuration")
        fun backup(): String = "Backed up"
    }
}

// Create the full nested hierarchy automatically
val adminTool = MatryoshkaTool.fromInstance(AdminTools())

// Flow:
// 1. LLM sees: admin_operations
// 2. LLM invokes: admin_operations -> sees: getStatus, user_management, system_config
// 3. LLM invokes: user_management -> sees: createUser, deleteUser, user_permissions
// 4. LLM invokes: user_permissions -> sees: grant, revoke
----
====

This approach provides several benefits:

* **Encapsulation**: All related tools are organized in a single class hierarchy
* **Automatic discovery**: No manual wiring - inner classes with `@MatryoshkaTools` are automatically included
* **Arbitrary depth**: Nest as many levels as needed to organize your tools logically
* **Mixed content**: Each level can have both direct `@LlmTool` methods and nested `@MatryoshkaTools` classes

===== Dynamically Configured Inner Tools

A powerful pattern with `MatryoshkaTool.selectable()` is creating inner tools that are *configured* based on the parameters passed when invoking the facade.
The selector function can create new tool instances with captured state, connection strings, or other configuration:

[tabs]
====
Java::
+
[source,java]
----
// MatryoshkaTool that configures database tools based on connection parameter
MatryoshkaTool databaseTool = MatryoshkaTool.selectable(
    "database",
    "Database operations. Pass 'connection' to configure tools.",
    Collections.emptyList(),  // Tools created dynamically
    Tool.InputSchema.of(
        Tool.Parameter.string("connection", "Database connection string")
    ),
    true,  // removeOnInvoke
    input -> {
        // Parse connection from input
        ObjectMapper mapper = new ObjectMapper();
        Map<String, Object> params = mapper.readValue(input, Map.class);
        String connection = (String) params.getOrDefault("connection", "localhost");

        // Create tools configured with the connection string
        return List.of(
            Tool.create("query", "Query database at " + connection, queryInput -> {
                // Tool has captured the connection string
                return Tool.Result.text("Queried " + connection + ": " + queryInput);
            }),
            Tool.create("insert", "Insert into database at " + connection, insertInput -> {
                return Tool.Result.text("Inserted into " + connection);
            })
        );
    }
);

// When LLM invokes with {"connection": "prod-db.example.com"}
// The injected tools are configured to use that specific connection
----

Kotlin::
+
[source,kotlin]
----
// MatryoshkaTool that configures database tools based on connection parameter
val databaseTool = MatryoshkaTool.selectable(
    name = "database",
    description = "Database operations. Pass 'connection' to configure tools.",
    innerTools = emptyList(),  // Tools created dynamically
    inputSchema = Tool.InputSchema.of(
        Tool.Parameter.string("connection", "Database connection string")
    ),
) { input ->
    // Parse connection from input
    val mapper = jacksonObjectMapper()
    val params = mapper.readValue(input, Map::class.java)
    val connection = params["connection"] as? String ?: "localhost"

    // Create tools configured with the connection string
    listOf(
        Tool.of("query", "Query database at $connection") { queryInput ->
            // Tool has captured the connection string
            Tool.Result.text("Queried $connection: $queryInput")
        },
        Tool.of("insert", "Insert into database at $connection") { insertInput ->
            Tool.Result.text("Inserted into $connection")
        }
    )
}

// When LLM invokes with {"connection": "prod-db.example.com"}
// The injected tools are configured to use that specific connection
----
====

This pattern is useful for:

* **Multi-tenant systems**: Configure tools with tenant-specific credentials or endpoints
* **Environment selection**: Let the LLM choose between dev/staging/prod environments
* **Stateful operations**: Create tools that share state (like a shopping cart's item list)
* **Dynamic service discovery**: Configure tools based on runtime service locations

====== Example: Stateful Shopping Cart Tools

[tabs]
====
Java::
+
[source,java]
----
MatryoshkaTool cartTool = MatryoshkaTool.selectable(
    "shopping_cart",
    "Shopping cart. Pass 'cart_id' to select which cart to operate on.",
    Collections.emptyList(),
    Tool.InputSchema.of(
        Tool.Parameter.string("cart_id", "Shopping cart ID")
    ),
    true,
    input -> {
        // Each invocation creates a fresh set of tools with shared state
        String cartId = parseCartId(input);
        List<String> cartItems = new ArrayList<>();  // Shared state

        return List.of(
            Tool.create("add_item", "Add item to cart " + cartId,
                Tool.InputSchema.of(Tool.Parameter.string("item", "Item name")),
                itemInput -> {
                    String item = parseItem(itemInput);
                    cartItems.add(item);  // Captured state
                    return Tool.Result.text("Added " + item + ". Total: " + cartItems.size());
                }
            ),
            Tool.create("view_cart", "View cart " + cartId + " contents", viewInput -> {
                return Tool.Result.text("Cart " + cartId + ": " + String.join(", ", cartItems));
            }),
            Tool.create("checkout", "Checkout cart " + cartId, checkoutInput -> {
                String total = calculateTotal(cartItems);
                cartItems.clear();
                return Tool.Result.text("Checked out " + cartId + " for " + total);
            })
        );
    }
);
----

Kotlin::
+
[source,kotlin]
----
val cartTool = MatryoshkaTool.selectable(
    name = "shopping_cart",
    description = "Shopping cart. Pass 'cart_id' to select which cart to operate on.",
    innerTools = emptyList(),
    inputSchema = Tool.InputSchema.of(
        Tool.Parameter.string("cart_id", "Shopping cart ID")
    ),
) { input ->
    // Each invocation creates a fresh set of tools with shared state
    val cartId = parseCartId(input)
    val cartItems = mutableListOf<String>()  // Shared state

    listOf(
        Tool.of(
            name = "add_item",
            description = "Add item to cart $cartId",
            inputSchema = Tool.InputSchema.of(Tool.Parameter.string("item", "Item name"))
        ) { itemInput ->
            val item = parseItem(itemInput)
            cartItems.add(item)  // Captured state
            Tool.Result.text("Added $item. Total: ${cartItems.size}")
        },
        Tool.of("view_cart", "View cart $cartId contents") { _ ->
            Tool.Result.text("Cart $cartId: ${cartItems.joinToString(", ")}")
        },
        Tool.of("checkout", "Checkout cart $cartId") { _ ->
            val total = calculateTotal(cartItems)
            cartItems.clear()
            Tool.Result.text("Checked out $cartId for $total")
        }
    )
}
----
====

===== Comparison with Other Approaches

Other agent frameworks address large tool collections with different approaches, each with trade-offs:

* **Anthropic's Tool Search Tool**: Uses a `defer_loading: true` flag to prevent tools from being loaded upfront. Tools are discovered via a separate "Tool Search Tool" that searches tool metadata. This requires maintaining searchable tool descriptions and adds latency for each discovery step.

* **LangGraph Dynamic Tool Calling**: Uses vector stores and semantic search to select relevant tools based on the user's query. This requires embedding infrastructure, vector database setup, and careful tuning of similarity thresholds.

* **Google ADK AgentTool**: Uses sub-agents that recursively delegate to other agents, each potentially having their own tool sets. Tool discovery is implicit through the agent hierarchy.

* **LangChain4j ToolProvider**: Provides a `ToolProvider` interface for dynamic tool selection, but it works _before_ the LLM call by analyzing the incoming user message. For example, "if the message contains 'booking', include booking tools." This is pre-filtering based on message content, not progressive disclosure through tool invocation. LangChain4j's documentation also suggests embedding-based classification, RAG over tool descriptions, or two-pass LLM selection—all requiring additional infrastructure or extra LLM calls.

MatryoshkaTool takes a fundamentally different approach: *invoke to reveal*.
Instead of searching through tool metadata, the LLM simply invokes a facade tool to unlock the tools it contains.

**Beyond Search: Dynamic Tool Configuration**

Crucially, MatryoshkaTool goes far beyond what any search-based approach can offer.
Search can only *find* pre-existing tools—it cannot create new ones or modify their behavior.
With `MatryoshkaTool.selectable()`, the selector function can:

* **Create entirely new tool instances** with different implementations based on runtime parameters
* **Capture configuration** (connection strings, credentials, endpoints) into the tool's behavior
* **Share mutable state** between the tools created in a single invocation
* **Customize tool descriptions** to reflect the specific context of use

For example, when an LLM invokes a "database" MatryoshkaTool with `{"connection": "prod-db.example.com"}`, the returned tools don't just have different descriptions—they have *different behavior* that operates on that specific database.
This is fundamentally impossible with search-based discovery, which can only return references to pre-defined tools.

This provides several advantages:

|===
|Aspect |Other Approaches |MatryoshkaTool

|*Infrastructure*
|Requires vector stores, embeddings, search indices, or pre-filtering logic
|No additional infrastructure required

|*Selection Timing*
|Before LLM call (pre-filtering based on message analysis)
|After LLM decides to invoke a facade (LLM-driven discovery)

|*Latency*
|Search/embedding adds latency; two-pass selection doubles LLM calls
|Instant unlock on invocation

|*Scalability*
|Search quality degrades with very large tool sets; requires careful tuning
|Scales to any number of tools via nesting without degradation

|*Determinism*
|Search results can vary based on embedding similarity
|Deterministic: invoking a facade always reveals the same tools

|*Cost*
|Embedding generation, vector search, or extra LLM calls incur compute costs
|No additional compute beyond the tool call itself

|*Dynamic Behavior*
|Can only return references to pre-existing tools
|Can create new tool instances with runtime-configured behavior
|===

The hierarchical nesting capability of MatryoshkaTool means you can organize thousands of tools into a logical tree structure.
The LLM navigates this tree by making simple invocations, with no search overhead at any level.
For example, a top-level "admin_operations" facade might reveal 5 category facades, each revealing 20 specific tools—giving access to 100 tools with at most 2 invocations.

[NOTE]
.MatryoshkaTool vs LlmReference
====
Both `MatryoshkaTool` and `LlmReference` expose tools to the LLM, but they serve different purposes:

**Use MatryoshkaTool when:**

* You have a single top-level capability that the LLM can invoke as one tool
* The prompt contribution is short and can fit in the tool description
* Example: A "database" tool that reveals query/insert/delete tools on invocation

**Use LlmReference when:**

* The prompt contribution is long or of general significance (appears in system prompt)
* You have a bunch of related tools, not just one top-level tool
* You need `notes()` for detailed usage instructions separate from the tool descriptions
* The reference contributes context beyond just tool availability

**Implementing both:**

Classes like `Memory` and `ToolishRag` implement both `Tool` and `LlmReference`, giving maximum flexibility:

[source,kotlin]
----
// Use as LlmReference (adds to system prompt + tools)
ai.withReference(memory).respond(...)

// Use as Tool directly (just the tool)
ai.withTool(memory).respond(...)
----

When used as an `LlmReference`, the `tools()` method exposes the inner tools directly.
When used as a `Tool`, the implementation wraps them in a `MatryoshkaTool` facade.
====
