[[reference.templates]]

=== Templates

Embabel supports Jinja templates for generating prompts.
You do this via the `PromptRunner.rendering(String)` method.

This method takes a Spring resource path to a Jinja template.
The default location is under `classpath:/prompts/` and the `.jinja` extension is added automatically.

You can also specify a full resource path with https://docs.spring.io/spring-framework/reference/core/resources.html[Spring resource conventions].

Once you have specified the template, you can create objects using a model map.

An example:

[tabs]
====
Java::
+
[source,java]
----
DistinctFactualAssertions distinctFactualAssertions = context.ai()
    .withLlm(properties.deduplicationLlm())
    // Jinjava template from classpath at prompts/factchecker/consolidate_assertions.jinja
    .rendering("factchecker/consolidate_assertions")
    .createObject(
            DistinctFactualAssertions.class,
            Map.of(
                    "assertions", allAssertions,
                    "reasoningWordCount", properties.reasoningWordCount()
            )
    );
----

Kotlin::
+
[source,kotlin]
----
val distinctFactualAssertions = context.ai()
    .withLlm(properties.deduplicationLlm())
    // Jinjava template from classpath at prompts/factchecker/consolidate_assertions.jinja
    .rendering("factchecker/consolidate_assertions")
    .createObject(
            DistinctFactualAssertions::class.java,
            mapOf(
                    "assertions" to allAssertions,
                    "reasoningWordCount" to properties.reasoningWordCount()
            )
    )
----
====

TIP: Don't rush to externalize prompts.
In modern languages with multi-line strings, it's often easier to keep prompts in the codebase.
Externalizing them can sacrifice type safety and lead to complexity and maintenance challenges.