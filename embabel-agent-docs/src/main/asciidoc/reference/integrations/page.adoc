[[reference.integrations]]
=== Integrations

[[reference.integrations__mcp]]
==== Model Context Protocol (MCP)

===== Publishing

====== Overview

Embabel Agent can expose your agents as MCP servers, making them available to external MCP clients such as Claude Desktop, VS Code extensions, or other MCP-compatible applications.
The framework provides automatic publishing of agent goals as tools and prompts without requiring manual configuration.

====== Server Configuration

Configure MCP server functionality in your `application.yml`.
The server type determines the execution mode:

[source,yaml]
----
spring:
  ai:
    mcp:
      server:
        type: SYNC  # or ASYNC
----

====== Server Types

Embabel Agent supports two MCP server execution modes controlled by the `spring.ai.mcp.server.type` property:

**SYNC Mode** (Default)::
- Blocking operations wrapped in reactive streams
- Simpler to develop and debug
- Suitable for most use cases
- Better error handling and logging

[source,yaml]
----
spring:
  ai:
    mcp:
      server:
        type: SYNC
----

**ASYNC Mode**::
- True non-blocking reactive operations
- Higher throughput for concurrent requests
- More complex error handling
- Suitable for high-performance scenarios

[source,yaml]
----
spring:
  ai:
    mcp:
      server:
        type: ASYNC
----

====== Transport Protocol

Embabel Agent uses **SSE (Server-Sent Events) transport**, exposing your MCP server at `http://localhost:8080/sse`.
This is compatible with Claude Desktop, MCP Inspector, Cursor, and most desktop MCP clients.

**Clients requiring Streamable HTTP**::
Some clients (e.g., OpenWebUI) require Streamable HTTP transport instead of SSE.
Use the `mcpo` proxy to bridge your SSE server:

[source,bash]
----
uvx mcpo --port 8000 --server-type sse -- http://localhost:8080/sse
----

Then connect your client to `http://localhost:8000`.

====== Automatic Publishing

**Tools**::
Agent goals are automatically published as MCP tools when annotated with `@Export(remote = true)`.
The `PerGoalMcpToolExportCallbackPublisher` automatically discovers and exposes these goals without any additional configuration.

**Prompts**::
Prompts are automatically generated for each goal's starting input types through the `PerGoalStartingInputTypesPromptPublisher`.
This provides ready-to-use prompt templates based on your agent definitions.

====== Exposing Agent Goals as Tools

Agent goals become MCP tools automatically when annotated with `@Export`:

[source,java]
----
@Agent(
    goal = "Provide weather information",
    backstory = "Weather service agent"
)
public class WeatherAgent {
    
    @Goal
    @Export(remote = true)  // Automatically becomes MCP tool
    public String getWeather(
        @Param("location") String location,
        @Param("units") String units
    ) {
        return "Weather for " + location + " in " + units;
    }
    
    @Goal
    public String internalMethod() {
        // Not exposed to MCP (no @Export annotation)
        return "Internal use only";
    }
}
----

====== Exposing Embabel `ToolObject` and `LlmReference` types as tools

A common requirement is to expose existing Embabel functionality via MCP.
For example, an `LlmReference` might be added to a `PromptRunner` but might also be used as an external tool via MCP.

To do this, use `McpToolExport` to create a bean of type `McpToolExportCallbackPublisher`.

For example, to expose a `ToolishRag` LLM reference as an MCP tool, define a Spring configuration class as follows:

[source,java]
----
@Configuration
public class RagMcpTools {

    @Bean
    McpToolExport ragTools( // <1>
            SearchOperations searchOperations) {
        var toolishRag = new ToolishRag(
                "docs",
                "Embabel docs",
                searchOperations
        );
        return McpToolExport.fromLlmReference(toolishRag); // <2>
    }
}
----

<1> Your bean should be of type `McpToolExport`
<2> Use `McpToolExport.fromLlmReference` to return the instance

====== Naming Strategies

When exporting tools, you can control how tool names are transformed using a naming strategy.
This is useful for namespacing tools when exporting from multiple sources to avoid naming conflicts.

**Using ToolObject with a naming strategy:**

[source,kotlin]
----
@Bean
fun prefixedTools(): McpToolExport {
    return McpToolExport.fromToolObject(
        ToolObject(
            objects = listOf(myToolInstance),
            namingStrategy = { "myservice_$it" }  // <1>
        )
    )
}
----

<1> All tool names will be prefixed with `myservice_`

Common naming strategies include:

* **Prefix**: `{ "namespace_$it" }` - adds a prefix to avoid conflicts
* **Uppercase**: `{ it.uppercase() }` - converts to uppercase
* **Identity**: `StringTransformer.IDENTITY` - preserves original names (default)

**LlmReference naming:**

When using `fromLlmReference`, the reference's built-in naming strategy is applied automatically.
This prefixes tool names with the lowercased, normalized reference name.
For example, an `LlmReference` named "MyAPI" will prefix all tools with `myapi_`.

[source,kotlin]
----
// Reference named "WeatherService" will prefix tools with "weatherservice_"
val reference = MyWeatherReference()  // name = "WeatherService"
McpToolExport.fromLlmReference(reference)
// Tool "getWeather" becomes "weatherservice_getWeather"
----

**Exporting multiple sources with different prefixes:**

[source,kotlin]
----
@Bean
fun multiSourceTools(): McpToolExport {
    return McpToolExport.fromToolObjects(
        listOf(
            ToolObject(
                objects = listOf(weatherTools),
                namingStrategy = { "weather_$it" }
            ),
            ToolObject(
                objects = listOf(stockTools),
                namingStrategy = { "stocks_$it" }
            )
        )
    )
}
----

====== Filtering Tools

You can filter which tools are exported using the `filter` property on `ToolObject`:

[source,kotlin]
----
@Bean
fun filteredTools(): McpToolExport {
    return McpToolExport.fromToolObject(
        ToolObject(
            objects = listOf(myToolInstance),
            filter = { it.startsWith("public_") }  // <1>
        )
    )
}
----

<1> Only tools whose names start with `public_` will be exported

You can combine naming strategies and filters:

[source,kotlin]
----
@Bean
fun combinedTools(): McpToolExport {
    return McpToolExport.fromToolObject(
        ToolObject(
            objects = listOf(myToolInstance),
            namingStrategy = { "api_$it" },
            filter = { !it.startsWith("internal") }  // <1>
        )
    )
}
----

<1> The filter is applied to the original tool name before the naming strategy transforms it

====== Exposing Tools on Spring Components in Spring AI style

It is also possible to expose tools on Spring components as with regular Spring AI.

For example:

[source,java]
----
@Component
public class CalculatorTools {

    @McpTool(name = "add", description = "Add two numbers together")
    public int add(
            @McpToolParam(description = "First number", required = true) int a,
            @McpToolParam(description = "Second number", required = true) int b) {
        return a + b;
    }

    @McpTool(name = "multiply", description = "Multiply two numbers")
    public double multiply(
            @McpToolParam(description = "First number", required = true) double x,
            @McpToolParam(description = "Second number", required = true) double y) {
        return x * y;
    }
}
----

Of course, you can inject the Embabel `Ai` interface to help do the work of the tools if you wish, or invoke other agents from within the tool methods.

For further information, see the https://docs.spring.io/spring-ai/reference/api/mcp/mcp-annotations-overview.html[Spring AI MCP Annotations Reference].

====== Server Architecture

The MCP server implementation uses several design patterns:

**Template Method Pattern**::
- `AbstractMcpServerConfiguration` provides common initialization logic
- Concrete implementations (`McpSyncServerConfiguration`, `McpAsyncServerConfiguration`) handle mode-specific details

**Strategy Pattern**::
- Server strategies abstract sync vs async operations
- Mode-specific implementations handle tool, resource, and prompt management

**Publisher Pattern**::
- Tools, resources, and prompts are discovered through publisher interfaces
- Automatic registration and lifecycle management
- Event-driven initialization ensures proper timing

====== Built-in Tools

Every MCP server includes a built-in `helloBanner` tool that displays server information:

[source,json]
----
{
  "type": "banner",
  "mode": "SYNC",
  "lines": [
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "Embabel Agent MCP SYNC Server",
    "Version: 0.3.0-SNAPSHOT",
    "Java: 21.0.2+13-LTS-58",
    "Started: 2025-01-17T14:23:47.785Z",
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  ]
}
----

[[reference.integrations__mcp_consuming]]
===== Consuming

Embabel Agent can consume external MCP servers as tool sources, automatically organizing them into Tool Groups that agents can use.

[[reference.integrations__mcp_docker]]
====== Docker Tools Integration

====== Configuration Approaches

**Docker MCP Gateway** (Recommended)::
Uses Docker Desktop's MCP Toolkit extension as a single gateway to multiple tools:

[source,yaml]
----
spring:
  ai:
    mcp:
      client:
        type: SYNC
        stdio:
          connections:
            docker-mcp:
              command: docker
              args: [mcp, gateway, run]
----

**Individual Containers**::
Run each MCP server as a separate Docker container:

[source,yaml]
----
spring:
  ai:
    mcp:
      client:
        type: SYNC
        stdio:
          connections:
            brave-search-mcp:
              command: docker
              args: [run, -i, --rm, -e, BRAVE_API_KEY, mcp/brave-search]
              env:
                BRAVE_API_KEY: ${BRAVE_API_KEY}
----

====== Available Tool Groups

Tool Groups are conditionally created based on configured MCP connections using `@ConditionalOnMcpConnection`:

[cols="1,2,3"]
|===
|Tool Group |Required Connections |Capabilities

|Web Tools
|`brave-search-mcp`, `fetch-mcp`, `wikipedia-mcp`, or `docker-mcp`
|Web search, URL fetching, Wikipedia queries

|Maps
|`google-maps-mcp` or `docker-mcp`
|Geocoding, directions, place search

|Browser Automation
|`puppeteer-mcp` or `docker-mcp`
|Page navigation, screenshots, form interaction

|GitHub
|`github-mcp` or `docker-mcp`
|Issues, pull requests, comments
|===

====== How It Works

The `@ConditionalOnMcpConnection` annotation checks for configured connections at startup:

[source,kotlin]
----
@Bean
@ConditionalOnMcpConnection("github-mcp", "docker-mcp")  // <1>
fun githubToolsGroup(): ToolGroup {
    return McpToolGroup(
        description = CoreToolGroups.GITHUB_DESCRIPTION,
        name = "docker-github",
        clients = mcpSyncClients,
        filter = { it.toolDefinition.name().contains("create_issue") }  // <2>
    )
}
----
<1> Bean created if *any* listed connection is configured
<2> Filter selects which MCP tools belong to this group

====== Custom Tool Groups

Define custom groups via configuration properties:

[source,yaml]
----
embabel:
  agent:
    platform:
      tools:
        includes:
          my-tools:
            description: "Custom tool collection"
            provider: "MyOrg"
            tools:
              - tool_name_suffix
----

[[reference.integrations__a2a]]
==== A2A

[[reference.integrations__observability]]
==== Observability

Embabel Agent provides a unified observability module that automatically traces agent lifecycle, actions, LLM calls, tool invocations, and more — with zero code changes.
It integrates with any OpenTelemetry-compatible backend (Zipkin, Langfuse, Jaeger, Prometheus, etc.).

===== Setup

Add the observability starter to your `pom.xml`:

[source,xml]
----
<dependency>
    <groupId>com.embabel.agent</groupId>
    <artifactId>embabel-agent-starter-observability</artifactId>
    <version>${embabel-agent.version}</version>
</dependency>
----

Then add an exporter dependency. For example, Zipkin:

[source,xml]
----
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-exporter-zipkin</artifactId>
</dependency>
----

Or Langfuse for LLM-focused observability:

[source,xml]
----
<dependency>
    <groupId>com.quantpulsar</groupId>
    <artifactId>opentelemetry-exporter-langfuse</artifactId>
    <version>0.4.0</version>
</dependency>
----

TIP: You can use multiple exporters simultaneously (e.g., Langfuse for traces + Prometheus for metrics).

===== Configuration

Enable observability and configure your exporter in `application.yml`:

[source,yaml]
----
embabel:
  observability:
    enabled: true
    service-name: my-agent-app

management:
  tracing:
    enabled: true
    sampling:
      probability: 1.0

  # Zipkin
  zipkin:
    tracing:
      endpoint: http://localhost:9411/api/v2/spans
----

For Langfuse:

[source,yaml]
----
management:
  langfuse:
    enabled: true
    endpoint: https://cloud.langfuse.com/api/public/otel  # or self-hosted URL
    public-key: pk-lf-...
    secret-key: sk-lf-...
----

===== What Gets Traced

All tracing is automatic once the module is on the classpath.
The following events are captured as OpenTelemetry spans, organized in a parent-child hierarchy:

[source]
----
Agent: CustomerServiceAgent (trace root)
├── planning:formulated [iteration=1, actions=3]
├── Action: AnalyzeRequest
│   └── ChatModel: gpt-4 (Spring AI)
│       └── tool:searchKnowledgeBase
├── Action: GenerateResponse
│   └── ChatModel: gpt-4 (Spring AI)
├── goal:achieved [RequestProcessed]
└── status: completed [duration=2340ms]
----

===== Tracing Configuration Properties

All tracing options are enabled by default and can be toggled individually:

[cols="2,1,3"]
|===
|Property |Default |Description

|`embabel.observability.enabled`
|`true`
|Master switch for observability

|`embabel.observability.service-name`
|`embabel-agent`
|Service name in traces

|`embabel.observability.trace-agent-events`
|`true`
|Agent lifecycle (creation, execution, completion, failures)

|`embabel.observability.trace-tool-calls`
|`true`
|Tool invocations with input/output

|`embabel.observability.trace-tool-loop`
|`true`
|Tool loop execution

|`embabel.observability.trace-llm-calls`
|`true`
|LLM calls with token usage

|`embabel.observability.trace-planning`
|`true`
|Planning and replanning iterations

|`embabel.observability.trace-state-transitions`
|`true`
|Workflow state changes

|`embabel.observability.trace-lifecycle-states`
|`true`
|WAITING, PAUSED, STUCK states

|`embabel.observability.trace-rag`
|`true`
|RAG events (request, response, pipeline)

|`embabel.observability.trace-ranking`
|`true`
|Ranking/selection events (agent routing)

|`embabel.observability.trace-dynamic-agent-creation`
|`true`
|Dynamic agent creation events

|`embabel.observability.trace-http-details`
|`false`
|HTTP request/response details (bodies, headers)

|`embabel.observability.trace-tracked-operations`
|`true`
|`@Tracked` annotation aspect

|`embabel.observability.mdc-propagation`
|`true`
|Propagate agent context into SLF4J MDC

|`embabel.observability.metrics-enabled`
|`true`
|Micrometer business metrics (counters, gauges)

|`embabel.observability.max-attribute-length`
|`4000`
|Max span attribute length before truncation
|===

===== Custom Operation Tracking with `@Tracked`

The `@Tracked` annotation lets you add observability spans to your own methods.
Inputs, outputs, duration, and errors are captured automatically.

[source,java]
----
@Tracked("enrichCustomer")
public Customer enrich(Customer input) {
    // Automatically creates a span with method arguments and return value
}
----

You can specify a type and description for richer traces:

[source,java]
----
@Tracked(
    value = "callPaymentApi",
    type = TrackType.EXTERNAL_CALL,
    description = "Payment gateway call"
)
public PaymentResult processPayment(Order order) {
    // ...
}
----

Available track types:

[cols="1,3"]
|===
|Type |Description

|`CUSTOM`
|General-purpose (default)

|`PROCESSING`
|Data processing operation

|`VALIDATION`
|Validation or verification step

|`TRANSFORMATION`
|Data transformation

|`EXTERNAL_CALL`
|External service/API call

|`COMPUTATION`
|Computation or calculation
|===

When called within an agent execution, `@Tracked` spans are automatically nested under the current action:

[source]
----
Agent: CustomerServiceAgent
├── Action: ProcessOrder
│   ├── @Tracked: enrichCustomer (PROCESSING)
│   ├── ChatModel: gpt-4
│   └── @Tracked: callPaymentApi (EXTERNAL_CALL)
└── status: completed
----

IMPORTANT: `@Tracked` uses Spring AOP proxies.
Internal method calls within the same class are *not* intercepted.
Extract tracked methods into a separate `@Component` bean for the annotation to work.

===== MDC Log Correlation

Agent context is automatically propagated into SLF4J MDC, enabling log filtering by agent run or action.

MDC keys set automatically:

[cols="2,3,2,2"]
|===
|MDC Key |Description |Set on |Removed on

|`embabel.agent.run_id`
|Agent process ID
|Agent creation
|Agent completed/failed/killed

|`embabel.agent.name`
|Agent name
|Agent creation
|Agent completed/failed/killed

|`embabel.action.name`
|Current action name
|Action start
|Action result
|===

Example Logback pattern:

[source,xml]
----
<pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} [runId=%X{embabel.agent.run_id} agent=%X{embabel.agent.name} action=%X{embabel.action.name}] - %msg%n</pattern>
----

This produces logs like:

[source]
----
14:23:45.123 [main] INFO  c.e.MyService [runId=abc-123 agent=CustomerServiceAgent action=AnalyzeRequest] - Processing request
----

To disable MDC propagation:

[source,yaml]
----
embabel:
  observability:
    mdc-propagation: false
----

===== Supported Backends

[cols="1,1,2"]
|===
|Backend |Type |Module

|Langfuse
|Traces
|`opentelemetry-exporter-langfuse`

|Zipkin
|Traces
|`opentelemetry-exporter-zipkin`

|OTLP (Jaeger, Tempo)
|Traces
|`opentelemetry-exporter-otlp`

|Prometheus
|Metrics
|`micrometer-registry-prometheus`
|===

For full details, see the https://github.com/embabel/embabel-agent/tree/main/embabel-agent-observability[Observability Module Documentation].